#!/usr/bin/env ruby

# tvgen: generate a collection of test vectors for a `tbgen`-generated testbench

require "pathname"
require "yaml"

require_relative "common"

def usage
  puts "Usage: tvgen [--verbose] <spec>"
end

def emit_tv(spec)
  spec[:tv_file].open("w") do |tv_io|
    tv_io.puts <<~HEADER
      // this file was generated by #{__FILE__}
      // do NOT edit it by hand
    HEADER

    all_wires = [*spec[:inputs], *spec[:outputs]]

    summary = all_wires.map { |x| "(#{x.name})" }.join("_")
    comment tv_io, summary
    tv_io.puts

    spec[:vector_specs].each do |vec_spec|
      desc = vec_spec.delete :_description
      comment tv_io, desc unless desc.nil?

      raw_wire = all_wires.map do |wire|
        wire_value = vec_spec.fetch(wire.name.to_sym, 0)
        scale = wire.size
        fmt = 2
        if wire_value == "x"
          wire_value * scale
        else
          wire_value = [wire_value.to_i].pack("L").unpack1("L") if wire_value.to_i.negative?
          wire_value.to_s(fmt).rjust(scale, "0")
        end
      end.join("_")
      tv_io.puts(raw_wire)
    end

    unless spec[:extra_vectors].nil?
      comment tv_io, "extra vectors included from #{spec[:extra_vectors]}"

      vecs = File.read spec[:extra_vectors]
      tv_io.puts vecs
    end
  end
end

if HELP
  usage
  exit
end

spec = ARGV.shift
if spec.nil?
  usage
  exit 1
end

spec = Pathname.new spec
barf "#{spec} must be a file" unless spec.file?

spec_dir = spec.dirname
verbose "directory for all relative spec paths: #{spec_dir}"

spec = YAML.safe_load File.read(spec), symbolize_names: true
verbose "loaded #{spec}"

fixup_spec! spec_dir, spec
emit_tv spec
